var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API Reference","title":"API Reference","text":"CurrentModule = Sequoia","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#API","page":"API Reference","title":"API","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This page is a dump of all the docstrings found in the code. ","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Sequoia]\nOrder = [:module, :type, :function, :macro]","category":"page"},{"location":"api/#Sequoia.SEQUOIA_History","page":"API Reference","title":"Sequoia.SEQUOIA_History","text":"SEQUOIA_History\n\nThis struct stores a collection of solution steps (SEQUOIA_Solution_step) obtained during the iterative optimization process in the SEQUOIA solver.\n\nFields\n\niterates::Vector{SEQUOIA_Solution_step}: A vector that holds multiple iteration steps, each represented by a SEQUOIA_Solution_step.\n\nConstructor\n\nDefault Constructor\n\nSEQUOIA_History()\n\nCreates an empty instance of SEQUOIA_History.\n\nWith Initial Iterates\n\nSEQUOIA_History(iterates::Vector{SEQUOIA_Solution_step})\n\nCreates a SEQUOIA_History with pre-populated iterates.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sequoia.SEQUOIA_Settings","page":"API Reference","title":"Sequoia.SEQUOIA_Settings","text":"SEQUOIA_Settings\n\nThe SEQUOIA_Settings struct stores the configuration parameters required for solving optimization  problems using the SEQUOIA method. It allows for extensive customization of solvers, convergence  criteria, and numerical tolerances.\n\nFields\n\nouter_method::Symbol: Specifies the outer optimization method. Supported methods:\n:SEQUOIA: SEQUOIA method.\n:QPM: Quadratic Programming Method.\n:AugLag: Augmented Lagrangian Method.\n:IntPt: Interior Point Method.\ninner_solver::Symbol: Specifies the inner solver for unconstrained subproblems. Supported solvers:\n:LBFGS: Limited-memory BFGS.\n:BFGS: BFGS solver.\n:Newton: Newton’s method.\n:GradientDescent: Gradient Descent.\n:NelderMead: Nelder-Mead method.\nfeasibility::Bool: Indicates whether the solver is solving a feasibility problem (true)  or optimizing an objective function (false).\nresid_tolerance::Float64: Residual tolerance for constraints. The solver considers the constraints  satisfied when the residual falls below this value.\nmax_iter_outer::Int: Maximum number of iterations allowed for the outer solver.\nmax_time_outer::Float64: Maximum computational time (in seconds) for the outer solver.\ngtol::Float64: Gradient norm tolerance for convergence.\nconv_crit::Symbol: Convergence criterion for the inner solver. Supported criteria:\n:GradientNorm: Convergence based on gradient norm.\n:MaxIterations: Convergence based on maximum number of iterations.\n:MaxTime: Convergence based on maximum computational time.\n:ConstraintResidual: Convergence based on constraint residual.\n:CombinedCrit: Combination of gradient norm, iteration count, or time limit.\n:AdaptiveIterations: Adaptive inner iterations based on outer iteration count.\nmax_iter_inner::Union{Nothing, Int}: Maximum number of iterations for the inner solver.  nothing indicates no explicit limit.\nmax_time_inner::Union{Nothing, Float64}: Maximum time (in seconds) for each inner solve call.  nothing indicates no time limit.\nstore_trace::Bool: Indicates whether to store partial iteration data for post-analysis.\ncost_tolerance::Union{Nothing, Float64}: Desired optimality gap. The solver stops when the  difference between the current solution and the optimal cost is below this threshold.  nothing indicates no explicit tolerance.\ncost_min::Union{Nothing, Float64}: Minimum cost value, useful for identifying unbounded problems.  nothing indicates no explicit minimum.\nstep_min::Union{Nothing, Float64}: Minimum step size during optimization.  nothing indicates no explicit minimum.\nsolver_params::Union{Nothing, Vector{Float64}}: Optional solver-specific parameters, such as  step sizes, penalty parameters, or warm-start multipliers. Default is nothing.\n\nConstructor\n\nFull Constructor\n\nSEQUOIA_Settings(outer_method::Symbol, inner_solver::Symbol, feasibility::Bool, \n                 resid_tolerance::Float64, max_iter_outer::Int, max_time_outer::Float64, \n                 gtol::Float64; \n                 conv_crit::Symbol = :GradientNorm, \n                 max_iter_inner::Union{Nothing, Int} = nothing, \n                 max_time_inner::Union{Nothing, Float64} = nothing, \n                 store_trace::Bool = false, \n                 cost_tolerance::Union{Nothing, Float64} = nothing, \n                 cost_min::Union{Nothing, Float64} = nothing, \n                 step_min::Union{Nothing, Float64} = nothing, \n                 solver_params::Union{Nothing, Vector{Float64}} = nothing)\n\nConstructs a SEQUOIA_Settings instance with user-defined or default parameters. Ensures validation  of settings.\n\nArguments\n\nouter_method: Outer optimization method (e.g., :SEQUOIA, :QPM).\ninner_solver: Inner solver for unconstrained problems (e.g., :LBFGS, :BFGS).\nfeasibility: Whether the solver is solving a feasibility problem.\nresid_tolerance: Residual tolerance for constraints.\nmax_iter_outer: Maximum number of iterations for the outer solver.\nmax_time_outer: Maximum time for the outer solver (in seconds).\ngtol: Gradient norm tolerance.\nconv_crit: Convergence criterion (default: :GradientNorm).\nmax_iter_inner: Maximum number of iterations for the inner solver (default: nothing).\nmax_time_inner: Maximum time for each inner solve call (default: nothing).\nstore_trace: Whether to store iteration data (default: false).\ncost_tolerance: Desired optimality gap (default: nothing).\ncost_min: Minimum allowed cost (default: nothing).\nstep_min: Minimum step size (default: nothing).\nsolver_params: Optional solver-specific parameters (default: nothing).\n\nThrows\n\nArgumentError if invalid parameters are provided.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sequoia.SEQUOIA_Solution_step","page":"API Reference","title":"Sequoia.SEQUOIA_Solution_step","text":"SEQUOIA_Solution_step\n\nRepresents the state of a solution at a particular iteration in the SEQUOIA optimization solver. This structure  captures detailed information about the solver's state, including the solution vector, metrics, constraints,  and status.\n\nFields\n\nouter_iteration_number::Int: The current outer iteration number.\nconvergence_metric::Float64: A metric used to measure convergence (e.g., feasibility, gradient norm, or optimality gap).\nsolver_status::Symbol: The status of the solver after this step. Typical values include:\n:first_order: Satisfied first-order optimality conditions.\n:acceptable: Satisfied acceptable convergence tolerance.\n:max_iter: Reached the maximum number of iterations.\n:max_time: Exceeded the maximum allowed computation time.\n:unbounded: Problem appears unbounded.\n:infeasible: Problem appears infeasible.\n:small_residual: Residual norm is below a small threshold.\n:small_step: Step size is below a small threshold.\n:unknown: Solver status is unknown.\ninner_comp_time::Float64: The time elapsed during the inner solve call, measured in seconds.\nnum_inner_iterations::Int: The number of inner iterations completed before exiting.\nx::Vector{Float64}: The solution vector at this iteration.\nfval::Float64: The value of the objective function at this iteration.\ngval::Vector{Float64}: The gradient of the objective function at this iteration.\ncval::Union{Nothing, Vector{Float64}}: The constraints evaluated at this iteration, or nothing if no constraints.\nsolver_params::Union{Nothing, Vector{Float64}}: Optional solver-related parameters, such as Lagrange multipliers, penalty parameters, or warm-start values.\nx_iterates::Union{Nothing, Vector{Vector{Float64}}}: A vector storing the history of all inner x iterates during this step, or nothing if not stored.\n\nConstructor\n\nFull Constructor\n\nSEQUOIA_Solution_step(outer_iteration_number::Int,\n                      convergence_metric::Float64,\n                      solver_status::Symbol,\n                      inner_comp_time::Float64,\n                      num_inner_iterations::Int,\n                      x::Vector{Float64},\n                      fval::Float64,\n                      gval::Vector{Float64},\n                      cval::Union{Nothing, Vector{Float64}} = nothing,\n                      solver_params::Union{Nothing, Vector{Float64}} = nothing,\n                      x_iterates::Union{Nothing, Vector{Vector{Float64}}} = nothing)\n\nCreates an instance of SEQUOIA_Solution_step with all relevant information about a solver step.\n\nArguments\n\nouter_iteration_number::Int: The current outer iteration number.\nconvergence_metric::Float64: A metric used to measure convergence (e.g., feasibility, gradient norm, or optimality gap).\nsolver_status::Symbol: The status of the solver after this step (e.g., :success, :failed, etc.).\ninner_comp_time::Float64: Time elapsed during the inner solve call, in seconds.\nnum_inner_iterations::Int: Number of inner iterations completed before exit.\nx::Vector{Float64}: The solution vector at this iteration.\nfval::Float64: Objective function value at this iteration.\ngval::Vector{Float64}: Gradient vector at this iteration.\ncval::Union{Nothing, Vector{Float64}}: (Optional) Constraints evaluated at this iteration. Defaults to nothing.\nsolver_params::Union{Nothing, Vector{Float64}}: (Optional) Solver-related parameters (e.g., penalty parameters). Defaults to nothing.\nx_iterates::Union{Nothing, Vector{Vector{Float64}}}: (Optional) History of all inner x iterates. Defaults to nothing.\n\nReturns\n\nA SEQUOIA_Solution_step instance.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sequoia.SEQUOIA_pb","page":"API Reference","title":"Sequoia.SEQUOIA_pb","text":"SEQUOIA_pb\n\nThe SEQUOIA_pb struct represents an optimization problem to be solved using the SEQUOIA framework. It encapsulates all necessary components of the problem, including the problem size, objective function, constraints, solver settings, and solution history.\n\nFields\n\nnvar::Int: The number of variables in the optimization problem (problem dimension). Must be a positive integer.\nx0::Union{Nothing, Vector{Float64}}: The initial guess for the variables. If set to nothing, it defaults to a zero vector of size nvar.\nis_minimization::Bool: Indicates whether the problem is a minimization problem (true) or a maximization problem (false). Defaults to true (minimization).\nobjective::Union{Nothing, Function}: The objective function to be minimized or maximized. Defaults to nothing. If set, must return a scalar value.\ngradient::Union{Nothing, Function}: The gradient of the objective function. Defaults to nothing. If not provided, it will be computed using automatic differentiation.\nconstraints::Union{Nothing, Function}: A function that returns the vector of constraints, or nothing if the problem has no constraints.\njacobian::Union{Nothing, Function}: The Jacobian of the constraints. Defaults to nothing. If not provided, it will be computed using automatic differentiation.\neqcon::Vector{Int}: Indices of equality constraints, assuming c_i(x) = 0. Defaults to an empty vector.\nineqcon::Vector{Int}: Indices of inequality constraints, assuming c_i(x) ≤ 0. Defaults to an empty vector.\nsolver_settings::SEQUOIA_Settings: Solver settings defining the optimization method, tolerances, and other parameters. Defaults to a SEQUOIA_Settings instance with preset configurations.\nsolution_history::SEQUOIA_History: Stores the history of solution steps for the optimization process. Defaults to an empty SEQUOIA_History.\ncutest_nlp::Union{Nothing, CUTEst.CUTEstModel}: An optional field for storing a CUTEst model instance, used for interfacing with external solvers or benchmark problems. Defaults to nothing.\n\nConstructor\n\nFull Constructor\n\nSEQUOIA_pb(nvar::Int;\n           x0::Union{Nothing, Vector{Float64}} = nothing,\n           is_minimization::Bool = true,\n           objective::Union{Nothing, Function} = nothing,\n           gradient::Union{Nothing, Function} = nothing,\n           constraints::Union{Nothing, Function} = nothing,\n           jacobian::Union{Nothing, Function} = nothing,\n           eqcon::Vector{Int} = Int[],\n           ineqcon::Vector{Int} = Int[],\n           solver_settings::SEQUOIA_Settings = SEQUOIA_Settings(:QPM, :LBFGS, false, 1e-6, 1000, 300, 1e-6),\n           solution_history::SEQUOIA_History = SEQUOIA_History(),\n           cutest_nlp::Union{Nothing, CUTEst.CUTEstModel} = nothing)\n\nConstructor for the SEQUOIA_pb struct, representing an optimization problem.\n\nArguments\n\nnvar::Int: The number of variables in the problem. Must be a positive integer.\nx0::Union{Nothing, Vector{Float64}} (optional): The initial guess for the variables. Defaults to a zero vector of size nvar if not provided.\nis_minimization::Bool (optional): Specifies whether the problem is a minimization (true) or maximization (false). Defaults to true.\nobjective::Union{Nothing, Function} (optional): The objective function for the problem. Defaults to nothing.\ngradient::Union{Nothing, Function} (optional): The gradient of the objective function. Defaults to nothing. If not provided, automatic differentiation will be used.\nconstraints::Union{Nothing, Function} (optional): A function returning the vector of constraints. Defaults to nothing.\njacobian::Union{Nothing, Function} (optional): The Jacobian matrix of the constraints. Defaults to nothing. If not provided, automatic differentiation will be used.\neqcon::Vector{Int} (optional): A vector specifying the indices of equality constraints. Defaults to an empty vector.\nineqcon::Vector{Int} (optional): A vector specifying the indices of inequality constraints. Defaults to an empty vector.\nsolver_settings::SEQUOIA_Settings (optional): The solver settings for the optimization problem. Defaults to a preset SEQUOIA_Settings instance.\nsolution_history::SEQUOIA_History (optional): The solution history for the problem. Defaults to an empty SEQUOIA_History.\ncutest_nlp::Union{Nothing, CUTEst.CUTEstModel} (optional): An optional CUTEst model instance. Defaults to nothing.\n\nReturns\n\nA SEQUOIA_pb instance representing the optimization problem.\n\nThrows\n\nArgumentError if nvar is not a positive integer.\nArgumentError if the length of x0 (if provided) does not match nvar.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sequoia.add_iterate!-Tuple{Any, Any}","page":"API Reference","title":"Sequoia.add_iterate!","text":"add_iterate!(history::Any, iterate::Any)\n\nFallback method to validate inputs before adding an iterate to a history.\n\nArguments\n\nhistory: Input to validate as SEQUOIA_History.\niterate: Input to validate as SEQUOIA_Solution_step.\n\nThrows\n\nArgumentError if inputs are invalid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.add_iterate!-Tuple{SEQUOIA_History, SEQUOIA_Solution_step}","page":"API Reference","title":"Sequoia.add_iterate!","text":"add_iterate!(history::SEQUOIA_History, iterate::SEQUOIA_Solution_step)\n\nAdds a new SEQUOIA_Solution_step to the SEQUOIA_History collection.\n\nArguments\n\nhistory::SEQUOIA_History: The history to add the iterate to.\niterate::SEQUOIA_Solution_step: The solution step to add.\n\nReturns\n\nThe updated SEQUOIA_History instance.\n\nThrows\n\nArgumentError if inputs are invalid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.alm_solve!-Tuple{SEQUOIA_pb, Vararg{Any, 7}}","page":"API Reference","title":"Sequoia.alm_solve!","text":"alm_solve!(problem::SEQUOIA_pb, inner_solver, options, time, x, previous_fval, iteration, inner_iterations)\n\nSolve a constrained optimization problem using the Augmented Lagrangian Method (ALM).\n\nArguments\n\nproblem::SEQUOIA_pb: A SEQUOIA_pb problem instance containing the objective, constraints, and settings.\ninner_solver: The unconstrained solver (e.g., Optim.LBFGS) for solving subproblems.\noptions: Optimization options for the inner_solver (e.g., tolerance, maximum iterations).\ntime: Accumulated time spent in solving the problem (updated in-place).\nx: Initial guess for the decision variables (updated in-place).\nprevious_fval: Previous objective value, used for convergence checks (updated in-place).\niteration: Current iteration number of the outer ALM loop (updated in-place).\ninner_iterations: Total inner solver iterations (updated in-place).\n\nReturns\n\ntime: Total time spent in solving the problem.\nx: Final optimized decision variables.\nprevious_fval: Final objective value.\niteration: Total number of outer iterations performed.\ninner_iterations: Total number of inner solver iterations performed.\n\nNotes\n\nThe augmented Lagrangian objective is minimized iteratively using inner_solver.\nLagrange multipliers (λ) are updated in each iteration using update_lag_mult!.\nPenalty parameters are adjusted dynamically based on the residuals and the damping factor.\nConvergence is determined by:\nResidual tolerance (r0(x, pb)).\nCost improvement tolerance (if specified).\nSolver convergence status (Optim.converged).\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.apply_defaults!-Tuple{SEQUOIA_Settings}","page":"API Reference","title":"Sequoia.apply_defaults!","text":"apply_defaults!(settings::SEQUOIA_Settings)\n\nApplies default values for optional parameters if not provided.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.auglag_grad!-Tuple{Any, Any, Any, Any, CUTEst.CUTEstModel}","page":"API Reference","title":"Sequoia.auglag_grad!","text":"auglag_grad!(g, x, μ, λ, problem::CUTEstModel)\n\nCompute the gradient of the augmented Lagrangian objective for a CUTEstModel problem and store it in g.\n\nArguments\n\ng: A preallocated gradient vector to store the result.\nx: The vector of decision variables.\nμ: The penalty parameter (scalar).\nλ: The vector of Lagrange multipliers for constraints.\nproblem: A CUTEstModel problem instance.\n\nNotes\n\nThe gradient is calculated as: ∇f(x) + μ * ∇r₀(x) + ∇con(x)ᵀ * λ where:\n∇f(x) is the gradient of the objective function.\n∇r₀(x) is the gradient of the penalty term.\n∇con(x) is the Jacobian of the constraints.\nOnly active inequality constraints contribute to the gradient, using a mask to selectively apply penalties.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.auglag_grad!-Tuple{Any, Any, Any, Any, SEQUOIA_pb}","page":"API Reference","title":"Sequoia.auglag_grad!","text":"auglag_grad!(g, x, μ, λ, problem::SEQUOIA_pb)\n\nCompute the gradient of the augmented Lagrangian objective for a SEQUOIA_pb problem and store it in g.\n\nArguments\n\ng: A preallocated gradient vector to store the result.\nx: The vector of decision variables.\nμ: The penalty parameter (scalar).\nλ: The vector of Lagrange multipliers for constraints.\nproblem: A SEQUOIA_pb problem instance.\n\nNotes\n\nThe gradient is calculated as: ∇f(x) + μ * ∇r₀(x) + ∇g(x)ᵀ * λ where:\n∇f(x) is the gradient of the objective function.\n∇r₀(x) is the gradient of the quadratic penalty term.\n∇g(x) is the Jacobian of the constraints.\nOnly active inequality constraints contribute to the gradient, using a mask to selectively apply penalties.\n\nEfficiency\n\nIf the Jacobian is sparse, operations are optimized for sparsity.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.auglag_obj-Tuple{Any, Any, Any, CUTEst.CUTEstModel}","page":"API Reference","title":"Sequoia.auglag_obj","text":"auglag_obj(x, μ, λ, problem::CUTEstModel)\n\nCompute the augmented Lagrangian objective for a CUTEstModel problem.\n\nArguments\n\nx: The vector of decision variables.\nμ: The penalty parameter (scalar).\nλ: The vector of Lagrange multipliers for constraints.\nproblem: A CUTEstModel problem instance.\n\nReturns\n\nA scalar value representing the augmented Lagrangian objective: f(x) + 0.5 * μ * (sum(con_eq.^2) + sum(max(0, con_ineq).^2)) + λᵀ * con\n\nNotes\n\ncon is split into equality constraints (con_eq) and inequality constraints (con_ineq) based on problem metadata.\nmax(0, ...) is applied to penalize only violated inequality constraints.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.auglag_obj-Tuple{Any, Any, Any, SEQUOIA_pb}","page":"API Reference","title":"Sequoia.auglag_obj","text":"auglag_obj(x, μ, λ, problem::SEQUOIA_pb)\n\nCompute the augmented Lagrangian objective for a SEQUOIA_pb problem.\n\nArguments\n\nx: The vector of decision variables.\nμ: The penalty parameter (scalar).\nλ: The vector of Lagrange multipliers for constraints.\nproblem: A SEQUOIA_pb problem instance.\n\nReturns\n\nA scalar value representing the augmented Lagrangian objective, calculated as: f(x) + μ * r₀(x) + λᵀ * g(x) where:\nf(x) is the original objective function.\nr₀(x) is the quadratic penalty for constraints.\ng(x) is the constraint violation vector, with max(0, g[j]) applied to inequality constraints.\n\nNotes\n\nInequality constraints (ineqcon) are penalized only if violated (using a ReLU-like max operation).\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.choose_inner_solver-Tuple{Symbol}","page":"API Reference","title":"Sequoia.choose_inner_solver","text":"choose_inner_solver(inner_solver::Symbol)\n\nSelect the appropriate Optim.jl solver for the given inner solver symbol.\n\nArguments\n\ninner_solver::Symbol: The name of the desired inner solver (e.g., :LBFGS).\n\nReturns\n\nAn instance of the corresponding Optim.jl solver.\n\nSupported Solvers\n\n:LBFGS\n:BFGS\n:Newton\n:GradientDescent\n:NelderMead\n\nNotes\n\nThrows an error if the solver name is invalid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.clear_history!-Tuple{SEQUOIA_History}","page":"API Reference","title":"Sequoia.clear_history!","text":"clear_history!(history::SEQUOIA_History)\n\nClears all iterates in the SEQUOIA_History.\n\nArguments\n\nhistory::SEQUOIA_History: The history to clear.\n\nReturns\n\nThe cleared SEQUOIA_History instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.cutest_to_sequoia-Tuple{CUTEst.CUTEstModel}","page":"API Reference","title":"Sequoia.cutest_to_sequoia","text":"cutest_to_sequoia(cutest_problem::CUTEstModel)\n\nConverts a CUTEst problem into a SEQUOIA_pb instance.\n\nArguments\n\ncutest_problem::CUTEstModel: The CUTEst problem instance to be converted.\n\nReturns\n\nA SEQUOIA_pb instance initialized with data from the CUTEst problem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.dresdx-Tuple{Any, CUTEst.CUTEstModel}","page":"API Reference","title":"Sequoia.dresdx","text":"dresdx(x, problem::CUTEstModel)\n\nCompute the Jacobian of the constraint violation vector for a CUTEst problem.\n\nArguments\n\nx: The vector of variables.\nproblem::CUTEstModel: A CUTEst optimization problem.\n\nReturns\n\nA sparse Jacobian matrix, dres, of size (total_constraints x nvar):\nRows correspond to the constraints returned by res.\nColumns correspond to the partial derivatives of the constraints with respect to variables x.\n\nNotes:\n\nEquality constraints (jeq rows):\nThese rows correspond to the derivatives of equality constraints ( c_i(x) ) with respect to ( x ).\nEach row represents the gradient of an equality constraint indexed in meta.jfix.\nFor a constraint ( ci(x) - lcon[i] = 0 ), the derivative is ( ∇ci(x) ).\nVariable equality constraints (ieq rows):\nThese rows represent equality conditions on variables, where ( x[i] = lvar[i] ) for indices in meta.ifix.\nEach row is a sparse vector with a single nonzero entry of 1.0 at the index corresponding to the variable being constrained.\nLower-bound inequality constraints (jlo rows):\nThese rows represent lower-bound constraints on the constraints ( ci(x) ), where ( lcon[i] - ci(x) ≥ 0 ).\nThe derivative for such constraints is the negation of ( ∇c_i(x) ), ensuring the violation vector reflects the direction of feasibility.\nLower-bound variable constraints (ilo rows):\nThese rows represent lower-bound conditions on variables ( lvar[i] - x[i] ≥ 0 ).\nEach row is a sparse vector with a single nonzero entry of -1.0 at the index of the constrained variable.\nUpper-bound inequality constraints (jup rows):\nThese rows represent upper-bound constraints on the constraints ( ci(x) ), where ( ci(x) - ucon[i] ≥ 0 ).\nThe derivative for such constraints is ( ∇c_i(x) ).\nUpper-bound variable constraints (iup rows):\nThese rows represent upper-bound conditions on variables ( x[i] - uvar[i] ≥ 0 ).\nEach row is a sparse vector with a single nonzero entry of 1.0 at the index of the constrained variable.\nRange constraints (jrg rows):\nFor constraints with both lower and upper bounds (( lcon[i] ≤ c_i(x) ≤ ucon[i] )), two rows are included:\nLower range violation: ( lcon[i] - ci(x) ) with derivative ( -∇ci(x) ).\nUpper range violation: ( ci(x) - ucon[i] ) with derivative ( ∇ci(x) ).\nRange variable constraints (irg rows):\nFor variables with both lower and upper bounds (( lvar[i] ≤ x[i] ≤ uvar[i] )), two rows are included:\nLower bound violation: ( lvar[i] - x[i] ), with derivative ( -1.0 ) for the constrained variable.\nUpper bound violation: ( x[i] - uvar[i] ), with derivative ( 1.0 ) for the constrained variable.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.feasibility_solve!-Tuple{SEQUOIA_pb, Vararg{Any, 6}}","page":"API Reference","title":"Sequoia.feasibility_solve!","text":"feasibility_solve!(problem::SEQUOIA_pb, inner_solver, options, time, x, previous_fval, inner_iterations)\n\nSolve the feasibility subproblem for a SEQUOIA_pb instance using an inner solver.\n\nArguments\n\nproblem::SEQUOIA_pb: The SEQUOIA optimization problem instance.\ninner_solver: The solver to use for the unconstrained subproblem (e.g., Optim.LBFGS).\noptions: A set of options for the solver (e.g., tolerances, maximum iterations).\ntime::Float64: The accumulated runtime, which will be updated by the function.\nx::Vector{Float64}: The decision variable vector, modified in place to store the current solution.\nprevious_fval::Float64: The previous objective function value, updated by the function.\ninner_iterations::Int: The accumulated number of inner solver iterations, updated by the function.\n\nReturns\n\nUpdated time, x, previous_fval, and inner_iterations.\n\nNotes\n\nIf problem.cutest_nlp is not nothing, the function assumes the problem uses the CUTEst NLP interface.\nThe function solves an unconstrained optimization problem defined by the residual function r0 and its gradient r0_gradient!.\nThe solution history is updated with a SEQUOIA_Solution_step object after solving the subproblem.\nThe solver status is determined based on the residual norm (result.minimum) and convergence status.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.get_all-Tuple{Any, Any}","page":"API Reference","title":"Sequoia.get_all","text":"get_all(history::Any, field::Any)\n\nFallback method to validate inputs before extracting field values from a history.\n\nArguments\n\nhistory: Input to validate as SEQUOIA_History.\nfield: Input to validate as a valid field.\n\nThrows\n\nArgumentError if inputs are invalid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.get_all-Tuple{SEQUOIA_History, Symbol}","page":"API Reference","title":"Sequoia.get_all","text":"get_all(history::SEQUOIA_History, field::Symbol) -> Vector{Any}\n\nRetrieves all values for a specified field from each iterate in the SEQUOIA_History.\n\nArguments\n\nhistory::SEQUOIA_History: The history to extract values from.\nfield::Symbol: The name of the field to retrieve.\n\nReturns\n\nA vector of values for the specified field from each iterate.\n\nThrows\n\nArgumentError if inputs are invalid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.ipm_grad!-Tuple{Any, Any, Any, CUTEst.CUTEstModel}","page":"API Reference","title":"Sequoia.ipm_grad!","text":"ipmgrad!(g, xa, μ, problem::CUTEstModel)\n\nCompute the gradient of the IPM objective function for a CUTEstModel problem.\n\nArguments\n\ng: A preallocated vector to store the gradient result.\nx_a: A combined vector of decision variables (x), Lagrange multipliers (λ).\nμ: The barrier penalty parameter (scalar).\nproblem: A CUTEstModel optimization problem.\n\nNotes\n\nThe gradient is computed in place and stored in g.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.ipm_grad!-Tuple{Any, Any, Any, SEQUOIA_pb}","page":"API Reference","title":"Sequoia.ipm_grad!","text":"ipm_grad!(g, x_a, μ, problem::SEQUOIA_pb)\n\nCompute the gradient of the IPM objective function for a SEQUOIA_pb problem.\n\nArguments\n\ng: A preallocated vector to store the gradient.\nx_a: A combined vector of:\nDecision variables (x).\nLagrange multipliers (λ) for constraints.\nμ: Barrier penalty parameter (scalar).\nproblem: A SEQUOIA_pb optimization problem.\n\nNotes\n\nComputes the gradient using automatic differentiation via ForwardDiff.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.ipm_obj-Tuple{Any, Any, CUTEst.CUTEstModel}","page":"API Reference","title":"Sequoia.ipm_obj","text":"ipm_obj(x_a, μ, problem::CUTEstModel)\n\nCompute the Interior Point Method (IPM) objective function for a CUTEstModel problem.\n\nArguments\n\nx_a: A combined vector of:\nDecision variables (x).\nLagrange multipliers (λ) for constraints.\nμ: Barrier penalty parameter (scalar).\nproblem: A CUTEstModel optimization problem.\n\nReturns\n\nA scalar value representing the IPM objective.\n\nNotes\n\nIncorporates both equality and inequality constraints from the CUTEstModel.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.ipm_obj-Tuple{Any, Any, SEQUOIA_pb}","page":"API Reference","title":"Sequoia.ipm_obj","text":"ipm_obj(x_a, μ, problem::SEQUOIA_pb)\n\nCompute the Interior Point Method (IPM) objective function for a SEQUOIA_pb problem.\n\nArguments\n\nx_a: A combined vector of:\nDecision variables (x).\nLagrange multipliers (λ) for constraints.\nμ: Barrier penalty parameter (scalar).\nproblem: A SEQUOIA_pb optimization problem.\n\nReturns\n\nA scalar value representing the IPM objective:\nThe objective is the sum of:\nSquared gradient norm of the Lagrangian.\nSquared residuals of the constraints.\nBarrier terms to enforce complementarity.\nSquared penalty for dual feasibility violation. \n\nNotes\n\nHandles both equality and inequality constraints.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.ipm_solve!-Tuple{SEQUOIA_pb, Vararg{Any, 7}}","page":"API Reference","title":"Sequoia.ipm_solve!","text":"ipm_solve!(problem::SEQUOIA_pb, inner_solver, options, time, x, previous_fval, iteration, inner_iterations)\n\nSolve a nonlinear optimization problem using the Interior Point Method (IPM).\n\nArguments\n\nproblem::SEQUOIA_pb: The SEQUOIA problem to solve.\ninner_solver: The unconstrained optimization solver (e.g., Optim.LBFGS).\noptions: Options for the inner solver (e.g., maximum iterations, tolerance).\ntime: Accumulated runtime (in seconds) of the solver.\nx: Initial guess for the decision variables.\nprevious_fval: Initial objective function value.\niteration: Current iteration number of the outer loop.\ninner_iterations: Accumulated number of iterations in the inner solver.\n\nReturns\n\ntime: Total runtime of the solver.\nx: Final solution for the decision variables.\nprevious_fval: Final objective function value.\niteration: Final iteration count of the outer loop.\ninner_iterations: Total iterations in the inner solver.\n\nNotes\n\nThe function solves the problem by iteratively minimizing the IPM objective (ipm_obj) using the given inner solver.\nBarrier methods are employed to ensure feasibility for inequality constraints.\nThe penalty parameter is adjusted dynamically to balance constraint violation and convergence.\nIntermediate results are stored in problem.solution_history for traceability.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.objective_setter_fallback-Tuple{Any}","page":"API Reference","title":"Sequoia.objective_setter_fallback","text":"objective_setter_fallback(objective::Any)\n\nValidates that the provided objective function is callable (i.e., a function).  If the input is not a callable function, an error is raised.\n\nArguments\n\nobjective: The object to validate as an objective function.\n\nThrows\n\nArgumentError if the objective is not a callable function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.pb_fallback-Tuple{Any}","page":"API Reference","title":"Sequoia.pb_fallback","text":"pb_fallback(pb::Any)\n\nValidates that the problem instance pb is of type SEQUOIA_pb. If it is not, throws an ArgumentError. This function is primarily used internally to ensure that the input to SEQUOIA-related functions is a valid SEQUOIA_pb instance.\n\nArguments\n\npb: The problem instance to validate.\n\nThrows\n\nArgumentError: If pb is not of type SEQUOIA_pb.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.qpm_grad!-Tuple{Any, Any, Any, CUTEst.CUTEstModel}","page":"API Reference","title":"Sequoia.qpm_grad!","text":"qpm_grad!(g, x, μ, problem::CUTEstModel)\n\nCompute the gradient of the quadratic penalty method objective function and store it in g.\n\nArguments\n\ng: A preallocated gradient vector.\nx: The decision variable vector.\nμ: The penalty parameter (scalar).\nproblem: An optimization problem of type CUTEstModel.\n\nNotes\n\nFor CUTEstModel, grad and dresdx are used.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.qpm_grad!-Tuple{Any, Any, Any, SEQUOIA_pb}","page":"API Reference","title":"Sequoia.qpm_grad!","text":"qpm_grad!(g, x, μ, problem::SEQUOIA_pb)\n\nCompute the gradient of the quadratic penalty method objective function and store it in g.\n\nArguments\n\ng: A preallocated gradient vector.\nx: The decision variable vector.\nμ: The penalty parameter (scalar).\nproblem: An optimization problem of type SEQUOIA_pb.\n\nNotes\n\nFor SEQUOIA_pb, problem.gradient and problem.jacobian are used.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.qpm_obj-Tuple{Any, Any, CUTEst.CUTEstModel}","page":"API Reference","title":"Sequoia.qpm_obj","text":"qpm_obj(x, μ, problem::CUTEstModel)\n\nCompute the quadratic penalty method objective function.\n\nArguments\n\nx: The decision variable vector.\nμ: The penalty parameter (scalar).\nproblem: An optimization problem of type CUTEstModel.\n\nReturns\n\nThe penalized objective value: f(x) + μ * r_0(x).\n\nNotes\n\nFor CUTEstModel, obj and res are used.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.qpm_obj-Tuple{Any, Any, SEQUOIA_pb}","page":"API Reference","title":"Sequoia.qpm_obj","text":"qpm_obj(x, μ, problem::SEQUOIA_pb)\n\nCompute the quadratic penalty method objective function.\n\nArguments\n\nx: The decision variable vector.\nμ: The penalty parameter (scalar).\nproblem: An optimization problem of type SEQUOIA_pb.\n\nReturns\n\nThe penalized objective value: f(x) + μ * r_0(x).\n\nNotes\n\nFor SEQUOIA_pb, problem.objective and problem.constraints are used.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.qpm_solve!-Tuple{SEQUOIA_pb, Vararg{Any, 7}}","page":"API Reference","title":"Sequoia.qpm_solve!","text":"qpm_solve!(problem::SEQUOIA_pb, inner_solver, options, time, x, previous_fval, iteration, inner_iterations)\n\nSolve an optimization problem using the Quadratic Penalty Method (QPM).\n\nArguments\n\nproblem: A SEQUOIA_pb optimization problem instance.\ninner_solver: The unconstrained solver from Optim.jl to solve subproblems (e.g., Optim.LBFGS).\noptions: Solver options for the inner solver.\ntime: Total elapsed time for the solver (updated in-place).\nx: The decision variable vector (updated in-place).\nprevious_fval: The previous objective function value (updated in-place).\niteration: The current outer iteration count (updated in-place).\ninner_iterations: The total number of inner iterations (updated in-place).\n\nReturns\n\nUpdated time, x, previous_fval, iteration, and inner_iterations.\n\nNotes\n\nThe method iteratively solves unconstrained subproblems using the penalty parameter.\nConvergence is checked based on residual tolerance and optional cost improvement.\nSupports both SEQUOIA_pb and CUTEstModel problems transparently.\nTracks intermediate solutions using SEQUOIA_Solution_step objects stored in problem.solution_history.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.r-Tuple{Any, Any, CUTEst.CUTEstModel}","page":"API Reference","title":"Sequoia.r","text":"r(x, tk, problem::CUTEstModel)\n\nCompute the penalty function r(x, t_k) for a CUTEstModel problem.\n\nArguments\n\nx: The vector of decision variables.\ntk: The threshold value for the objective function.\nproblem: A CUTEstModel problem instance.\n\nReturns\n\nA scalar value representing the penalty function: r(x, tk) = r0(x) + 0.5 * max(0, f(x) - t_k)^2, where:\nr_0(x) is the constraint violation penalty.\nmax(0, f(x) - t_k) penalizes the objective for exceeding the threshold.\n\nNotes\n\nr_0(x) penalizes equality and inequality constraint violations.\nThe objective penalty applies only when f(x) > t_k.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.r-Tuple{Any, Any, SEQUOIA_pb}","page":"API Reference","title":"Sequoia.r","text":"r(x, tk, problem::SEQUOIA_pb)\n\nCompute the penalty function r(x, tk) for a `SEQUOIApb` problem.\n\nArguments\n\nx: The vector of decision variables.\ntk: The threshold value for the objective function.\nproblem: A SEQUOIA_pb problem instance.\n\nReturns\n\nA scalar value representing the penalty function: r(x, tk) = r0(x) + 0.5 * max(0, f(x) - t_k)^2, where:\nr_0(x) is the constraint violation penalty.\nmax(0, f(x) - t_k) penalizes the objective for exceeding the threshold.\n\nNotes\n\nr_0(x) penalizes equality and inequality constraint violations.\nThe objective penalty applies only when f(x) > t_k.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.r0-Tuple{Any, CUTEst.CUTEstModel}","page":"API Reference","title":"Sequoia.r0","text":"r0(x, problem::CUTEstModel)\n\nCompute the residual function r_0(x) for a CUTEstModel problem.\n\nArguments\n\nx: The vector of variables.\nproblem::CUTEstModel: A CUTEst optimization problem.\n\nReturns\n\nA scalar value representing the residual function, calculated as:   r_0(x) = 1/2 * (sum(con[i]^2 for i in eqcon) + sum(max(0, con[j])^2 for j in ineqcon))   where:\nEquality constraints (eqcon) include the first jfix + ifix constraints.\nInequality constraints (ineqcon) are the remaining constraints.\n\nNotes\n\nThe function computes penalties for equality constraints (eqcon) using squared residuals.\nInequality constraints (ineqcon) are only penalized for violations (using a ReLU-like quadratic penalty).\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.r0-Tuple{Any, SEQUOIA_pb}","page":"API Reference","title":"Sequoia.r0","text":"r0(x, problem::SEQUOIA_pb)\n\nCompute the residual function ( r0(x) ) for a `SEQUOIApb` problem.\n\nArguments\n\nx: The vector of variables.\nproblem::SEQUOIA_pb: A SEQUOIA optimization problem.\n\nReturns\n\nA scalar value representing the residual function, calculated as:\n\nr_0(x) = 1/2 * (sum(con[i]^2 for i in eqcon) + sum(max(0, con[j])^2 for j in ineqcon))\n\nNotes\n\nThe function computes penalties for equality constraints (eqcon) and inequality constraints (ineqcon) using squared residuals.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.r0_gradient!-Tuple{Any, Any, CUTEst.CUTEstModel}","page":"API Reference","title":"Sequoia.r0_gradient!","text":"r0_gradient!(g, x, problem::CUTEstModel)\n\nCompute the gradient of the residual function ∇r_0(x) for a CUTEstModel problem and store it in g.\n\nArguments\n\ng: A preallocated vector to store the gradient. Must have the same size as x.\nx: The vector of variables.\nproblem::CUTEstModel: A CUTEst optimization problem.\n\nNotes\n\nThe gradient is computed as:   g = J' * con   where:\nJ is the Jacobian of the constraints.\ncon includes squared penalties for equality constraints and ReLU penalties for inequality constraints.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.r0_gradient!-Tuple{Any, Any, SEQUOIA_pb}","page":"API Reference","title":"Sequoia.r0_gradient!","text":"r0_gradient!(g, x, problem::SEQUOIA_pb)\n\nCompute the gradient of the residual function ∇r0(x) for a `SEQUOIApbproblem and store it ing`.\n\nArguments\n\ng: A preallocated vector to store the gradient. Must have the same size as x.\nx: The vector of variables.\nproblem::SEQUOIA_pb: A SEQUOIA optimization problem.\n\nNotes\n\nThe gradient is computed as:   g = J' * con   where:\nJ is the Jacobian of the constraints.\nconstraint_val includes penalties for equality and inequality constraints.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.r_gradient!-Tuple{Any, Any, Any, CUTEst.CUTEstModel}","page":"API Reference","title":"Sequoia.r_gradient!","text":"r_gradient!(grad_storage, x, tk, problem::CUTEstModel)\n\nCompute the gradient of the penalty function r(x, tk) for a CUTEstModel problem and store it in `gradstorage`.\n\nArguments\n\ngrad_storage: A preallocated vector to store the gradient result.\nx: The vector of decision variables.\ntk: The threshold value for the objective function.\nproblem: A CUTEstModel problem instance.\n\nNotes\n\nThe gradient is computed as: ∇r(x, tk) = ∇r0(x) + ∇f(x) * max(0, f(x) - t_k), where:\n∇r_0(x) is the gradient of the constraint violation penalty.\n∇f(x) is the gradient of the objective function.\nThe grad_storage vector is updated in place.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.r_gradient!-Tuple{Any, Any, Any, SEQUOIA_pb}","page":"API Reference","title":"Sequoia.r_gradient!","text":"r_gradient!(grad_storage, x, tk, problem::SEQUOIA_pb)\n\nCompute the gradient of the penalty function r(x, tk) for a `SEQUOIApbproblem and store it ingrad_storage`.\n\nArguments\n\ngrad_storage: A preallocated vector to store the gradient result.\nx: The vector of decision variables.\ntk: The threshold value for the objective function.\nproblem: A SEQUOIA_pb problem instance.\n\nNotes\n\nThe gradient is computed as: ∇r(x, tk) = ∇r0(x) + ∇f(x) * max(0, f(x) - t_k), where:\n∇r_0(x) is the gradient of the constraint violation penalty.\n∇f(x) is the gradient of the objective function.\nThe grad_storage vector is updated in place.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.res-Tuple{Any, CUTEst.CUTEstModel}","page":"API Reference","title":"Sequoia.res","text":"res(x, problem::CUTEstModel)\n\nCompute the violation of equality, inequality, and range constraints for a CUTEst problem.\n\nArguments\n\nx: The vector of variables.\nproblem::CUTEstModel: A CUTEst optimization problem.\n\nReturns\n\nA vector of violations, structured as follows:\nEquality constraint violations (jeq): The first jeq elements correspond to the violation of equality constraints, c_i(x) - lcon[i] = 0, where c_i are the equality constraints defined in jfix.\nVariable equality violations (ieq): The next ieq elements correspond to variable equality constraints, x[i] - lvar[i] = 0, where indices are defined in ifix.\nLower bound constraint violations (jlo): The next jlo elements represent lower-bound constraint violations, lcon[i] - c_i(x) >= 0, where indices are defined in jlow.\nLower bound variable violations (ilo): The next ilo elements correspond to lower-bound variable violations, lvar[i] - x[i] >= 0, where indices are defined in ilow.\nUpper bound constraint violations (jup): The next jup elements represent upper-bound constraint violations, c_i(x) - ucon[i] >= 0, where indices are defined in jupp.\nUpper bound variable violations (iup): The next iup elements correspond to upper-bound variable violations, x[i] - uvar[i] >= 0, where indices are defined in iupp.\nConstraint range violations (2 * jrg): For each jrg, two entries correspond to:\nLower range violation: lcon[i] - c_i(x).\nUpper range violation: c_i(x) - ucon[i].\nVariable range violations (2 * irg): For each irg, two entries correspond to:\nLower box violation: lvar[i] - x[i].\nUpper box violation: x[i] - uvar[i].\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.reset_solution_history!-Tuple{SEQUOIA_pb}","page":"API Reference","title":"Sequoia.reset_solution_history!","text":"reset_solution_history!(pb::SEQUOIA_pb)\n\nResets the solution history for the SEQUOIA_pb problem.\n\nArguments\n\npb: The SEQUOIA_pb problem instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.sequoia_solve!-Tuple{SEQUOIA_pb, Vararg{Any, 7}}","page":"API Reference","title":"Sequoia.sequoia_solve!","text":"sequoia_solve!(problem::SEQUOIA_pb, inner_solver, options, time, x, tk, iteration, inner_iterations)\n\nSolve an optimization problem using SEQUOIA's modified bisection algorithm.\n\nArguments\n\nproblem::SEQUOIA_pb: The optimization problem to solve, represented as a SEQUOIA_pb instance.\ninner_solver: An Optim solver instance for solving subproblems (e.g., Optim.LBFGS).\noptions: Optimization options for the inner solver (e.g., tolerances, maximum iterations).\ntime::Float64: Accumulated computation time (updated in place).\nx::Vector{Float64}: The decision variable vector (updated in place).\ntk::Float64: Current threshold value for the objective (updated in place).\niteration::Int: Current outer iteration count (updated in place).\ninner_iterations::Int: Accumulated inner solver iterations (updated in place).\n\nReturns\n\nUpdated time, x, tk, iteration, and inner_iterations.\n\nAlgorithm Overview\n\nInitialize the penalty parameter dk and thresholds tl and tu.\nSolve two subproblems:\nUpper threshold problem: r(x, tu, pb)\nLower threshold problem: r(x, tl, pb)\nUpdate the decision variable x based on convergence criteria.\nAdjust the penalty parameter dk based on the results of the subproblems.\nRepeat until convergence, maximum iterations, or time limit is reached.\n\nConvergence Criteria\n\nConverges if:\nThe step size dk is below the tolerance, and\nResidual rk is within the residual tolerance.\nTerminates early if:\nStep size dk becomes too small, or\nThe objective threshold tk falls below the minimum allowed value.\n\nNotes\n\nThe function supports both SEQUOIA and CUTEst optimization problems.\nSolution history is stored in problem.solution_history if trace storage is enabled.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.set_constraints!-Tuple{SEQUOIA_pb, Function, Vector{Int64}, Vector{Int64}}","page":"API Reference","title":"Sequoia.set_constraints!","text":"set_constraints!(pb::SEQUOIA_pb, constraints::Function, eqcon::Vector{Int}, ineqcon::Vector{Int}; jacobian::Union{Nothing, Function}=nothing, reset_history::Bool=true)\n\nSets the constraints and optional Jacobian for the SEQUOIA_pb problem. You can also specify equality and inequality constraint indices. Optionally resets the solution history.\n\nArguments\n\npb: The SEQUOIA_pb problem instance.\nconstraints: The new constraints function, which must return a vector of constraints.\neqcon: A vector of indices corresponding to equality constraints (i.e., c_i(x) = 0). Defaults to nothing.\nineqcon: A vector of indices corresponding to inequality constraints (i.e., c_i(x) ≤ 0). Defaults to nothing.\njacobian: (Optional) The Jacobian function. If not provided, it will be auto-generated using automatic differentiation.\nreset_history: (Optional) A boolean flag indicating whether to reset the solution history. Defaults to true.\n\nThrows\n\nArgumentError: If the constraints are not callable or their dimensions do not match the provided indices.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.set_initial_guess!-Tuple{SEQUOIA_pb, Vector{Float64}}","page":"API Reference","title":"Sequoia.set_initial_guess!","text":"set_initial_guess!(pb::SEQUOIA_pb, x0::Vector{Float64})\n\nSets the initial guess (x0) for the SEQUOIA_pb problem. This function validates the input to ensure the length of x0 matches the problem dimension (nvar).\n\nArguments\n\npb: The SEQUOIA_pb problem instance.\nx0: The new initial guess vector. Must have a length equal to pb.nvar.\n\nThrows\n\nArgumentError: If the length of x0 does not match pb.nvar.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.set_objective!-Tuple{SEQUOIA_pb, Function}","page":"API Reference","title":"Sequoia.set_objective!","text":"set_objective!(pb::SEQUOIA_pb, obj::Function; gradient::Union{Nothing, Function}=nothing, reset_history::Bool=true)\n\nSets the objective function for the SEQUOIA_pb problem and optionally resets the solution history. You can also provide a gradient, otherwise, the gradient will be generated automatically.\n\nArguments\n\npb: The SEQUOIA_pb problem instance.\nobj: The new objective function, which must return a scalar value.\ngradient: (Optional) The gradient function. If not provided, it will be auto-generated using automatic differentiation.\nreset_history: (Optional) A boolean flag indicating whether to reset the solution history. Defaults to true.\n\nThrows\n\nArgumentError: If the objective function is not callable or its output is not a scalar.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.set_options-Tuple{SEQUOIA_Settings}","page":"API Reference","title":"Sequoia.set_options","text":"set_options(settings::SEQUOIA_Settings)\n\nConfigure options for the Optim.jl solver based on SEQUOIA settings.\n\nArguments\n\nsettings::SEQUOIA_Settings: Optimization settings including convergence criteria, tolerance, and trace options.\n\nReturns\n\nAn instance of Optim.Options configured for the specified criteria.\n\nNotes\n\nSupports :GradientNorm, :MaxIterations, :MaxTime, and :CombinedCrit as convergence criteria.\nThrows an error if settings.conv_crit is invalid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.set_solver_settings!-Tuple{Any, Any}","page":"API Reference","title":"Sequoia.set_solver_settings!","text":"set_solver_settings!(pb::Any, settings::Any)\n\nSets the solver settings for a SEQUOIA problem. This function first validates that the problem instance pb is of type SEQUOIA_pb and that the settings are valid SEQUOIA_Settings. If any validation fails, an error is thrown.\n\nArguments\n\npb: The problem instance to which the solver settings are being applied. Must be of type SEQUOIA_pb.\nsettings: The solver settings to be applied. Must be of type SEQUOIA_Settings.\n\nThrows\n\nArgumentError: If pb is not of type SEQUOIA_pb.\nArgumentError: If settings is not of type SEQUOIA_Settings.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.set_solver_settings!-Tuple{SEQUOIA_pb, SEQUOIA_Settings}","page":"API Reference","title":"Sequoia.set_solver_settings!","text":"set_solver_settings!(pb::SEQUOIA_pb, settings::SEQUOIA_Settings)\n\nSets the solver settings for the SEQUOIA_pb problem.\n\nArguments\n\npb: The SEQUOIA_pb problem instance.\nsettings: The new solver settings (SEQUOIA_Settings).\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.solve!-Tuple{SEQUOIA_pb}","page":"API Reference","title":"Sequoia.solve!","text":"solve!(problem::SEQUOIA_pb)\n\nSolve a constrained optimization problem using SEQUOIA.\n\nArguments\n\nproblem::SEQUOIA_pb: The optimization problem to solve, including settings, initial guess, and constraints.\n\nWorkflow\n\nInitializes inner solver based on problem.solver_settings.inner_solver.\nValidates solver parameters for the selected outer method (:QPM, :AugLag, :IntPt, :SEQUOIA).\nIf problem.solver_settings.feasibility is true, runs a feasibility solve.\nDelegates the main optimization task to the appropriate solver (qpm_solve!, alm_solve!, ipm_solve!, sequoia_solve!).\n\nReturns\n\nUpdates the problem.solution_history and modifies problem.x0 with the final solution.\n\nNotes\n\nSupports multiple outer methods and solvers with customizable settings.\nThrows an error if solver parameters are mismatched or unsupported methods are used.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.solver_settings_fallback-Tuple{Any}","page":"API Reference","title":"Sequoia.solver_settings_fallback","text":"solver_settings_fallback(solver_settings::Any)\n\nValidates that the solver settings are of type SEQUOIA_Settings.\n\nArguments\n\nsolver_settings: The solver settings to validate.\n\nThrows\n\nArgumentError if solver_settings is not of type SEQUOIA_Settings.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.update_lag_mult!-Tuple{Any, Any, Any, CUTEst.CUTEstModel}","page":"API Reference","title":"Sequoia.update_lag_mult!","text":"update_lag_mult!(x, μ, λ, problem::CUTEstModel)\n\nUpdate the Lagrange multipliers for a CUTEstModel problem.\n\nArguments\n\nx: The vector of decision variables.\nμ: The penalty parameter (scalar).\nλ: The vector of Lagrange multipliers for constraints (modified in place).\nproblem: A CUTEstModel problem instance.\n\nNotes\n\nEquality constraints are updated using: λ[eq_indices] += μ * con[eq_indices]\nInequality constraints are updated using: λ[ineq_indices] = max(0, λ[ineq_indices] + μ * con[ineq_indices])\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.update_lag_mult!-Tuple{Any, Any, Any, SEQUOIA_pb}","page":"API Reference","title":"Sequoia.update_lag_mult!","text":"update_lag_mult!(x, μ, λ, problem::SEQUOIA_pb)\n\nUpdate the Lagrange multipliers for a SEQUOIA_pb problem.\n\nArguments\n\nx: The vector of decision variables.\nμ: The penalty parameter (scalar).\nλ: The vector of Lagrange multipliers for constraints (modified in place).\nproblem: A SEQUOIA_pb problem instance.\n\nNotes\n\nEquality constraints (eqcon) are updated using the formula: λ[i] = λ[i] + μ * g[i]\nInequality constraints (ineqcon) are updated using: λ[i] = max(0, λ[i] + μ * g[i]) where g[i] is the constraint violation.\n\nEfficiency\n\nThe implementation efficiently handles in-place updates for λ without additional memory allocation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.validate_constraints!-Tuple{SEQUOIA_pb}","page":"API Reference","title":"Sequoia.validate_constraints!","text":"validate_constraints!(pb::SEQUOIA_pb)\n\nValidates the constraints function if provided, ensuring consistency with the specified equality and inequality constraints.  If no constraints are provided, a warning is issued. Also validates the Jacobian if needed.\n\nArguments\n\npb: The SEQUOIA_pb problem instance.\n\nThrows\n\nArgumentError if the constraints are inconsistent with the equality/inequality indices or if the Jacobian is invalid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.validate_convergence_criteria-Tuple{Symbol}","page":"API Reference","title":"Sequoia.validate_convergence_criteria","text":"validate_convergence_criteria(conv_crit::Symbol)\n\nValidates that the convergence criterion is one of the supported options.  Throws an ArgumentError if the convergence criterion is invalid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.validate_field-Tuple{Any}","page":"API Reference","title":"Sequoia.validate_field","text":"validate_field(field::Any)\n\nValidates that the input field is of type Symbol.\n\nArguments\n\nfield::Any: The input to validate.\n\nThrows\n\nArgumentError: If field is not of type Symbol.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.validate_field-Tuple{Symbol}","page":"API Reference","title":"Sequoia.validate_field","text":"validate_field(field::Symbol)\n\nValidates that the field exists in the SEQUOIA_Solution_step struct.\n\nArguments\n\nfield::Symbol: The field to validate.\n\nThrows\n\nArgumentError if the field is not a valid field of SEQUOIA_Solution_step.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.validate_gradient!-Tuple{SEQUOIA_pb}","page":"API Reference","title":"Sequoia.validate_gradient!","text":"validate_gradient!(pb::SEQUOIA_pb)\n\nValidates that the gradient function is callable and returns a vector of length nvar.  If no gradient is provided, automatic differentiation using ForwardDiff is used as a fallback.\n\nArguments\n\npb: The SEQUOIA_pb problem instance.\n\nThrows\n\nArgumentError if the gradient function does not return a vector of Float64 of the correct size.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.validate_history-Tuple{Any}","page":"API Reference","title":"Sequoia.validate_history","text":"validate_history(history::Any)\n\nValidates that the input is a valid SEQUOIA_History instance.\n\nArguments\n\nhistory: Input to validate.\n\nThrows\n\nArgumentError if the input is not of type SEQUOIA_History.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.validate_inner_solver-Tuple{Symbol}","page":"API Reference","title":"Sequoia.validate_inner_solver","text":"validate_inner_solver(inner_solver::Symbol)\n\nValidates that the inner solver is one of the supported options. Throws an ArgumentError if the inner solver is invalid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.validate_iterate-Tuple{Any}","page":"API Reference","title":"Sequoia.validate_iterate","text":"validate_iterate(iterate::Any)\n\nValidates that the input is a valid SEQUOIA_Solution_step instance.\n\nArguments\n\niterate: Input to validate.\n\nThrows\n\nArgumentError if the input is not of type SEQUOIA_Solution_step.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.validate_jacobian!-Tuple{SEQUOIA_pb}","page":"API Reference","title":"Sequoia.validate_jacobian!","text":"validate_jacobian!(pb::SEQUOIA_pb)\n\nValidates the Jacobian function if provided. If no Jacobian is defined, automatic differentiation with ForwardDiff is used as a fallback.\n\nArguments\n\npb: The SEQUOIA_pb problem instance.\n\nThrows\n\nArgumentError if the Jacobian is invalid or does not return the correct matrix size.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.validate_numeric!-Tuple{SEQUOIA_Settings}","page":"API Reference","title":"Sequoia.validate_numeric!","text":"validate_numeric!(settings::SEQUOIA_Settings)\n\nValidates numeric parameters such as iteration counts, times, and tolerances.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.validate_nvar-Tuple{Int64}","page":"API Reference","title":"Sequoia.validate_nvar","text":"validate_nvar(nvar::Int)\n\nValidates that the number of variables nvar is a positive integer.\n\nArguments\n\nnvar: The number of variables to validate.\n\nThrows\n\nArgumentError if nvar is not a positive integer.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.validate_objective-Tuple{Union{Nothing, Function}, Vector{Float64}}","page":"API Reference","title":"Sequoia.validate_objective","text":"validate_objective(objective::Union{Nothing, Function}, x0::Vector{Float64})\n\nValidates that the objective function is callable and returns a scalar of type Float64.  Throws an error if the objective is not defined or returns invalid output.\n\nArguments\n\nobjective: The objective function to validate.\nx0: The initial guess vector to test the objective function.\n\nThrows\n\nArgumentError if the objective is not defined or does not return a scalar Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.validate_outer_method-Tuple{Symbol}","page":"API Reference","title":"Sequoia.validate_outer_method","text":"validate_outer_method(outer_method::Symbol)\n\nValidates that the outer method is one of the supported options. Throws an ArgumentError if the outer method is invalid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.validate_pb!-Tuple{SEQUOIA_pb}","page":"API Reference","title":"Sequoia.validate_pb!","text":"validate_pb!(pb::SEQUOIA_pb)\n\nMain validation function for a SEQUOIA_pb optimization problem. Ensures all required components of the problem  are correctly defined, including the number of variables, initial guess, objective function, gradient, constraints,  and solver settings.\n\nArguments\n\npb: The SEQUOIA_pb problem instance to validate.\n\nThrows\n\nArgumentError if any of the fields or functions in the problem are incorrectly defined or inconsistent.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.validate_sequoia_settings!-Tuple{SEQUOIA_Settings}","page":"API Reference","title":"Sequoia.validate_sequoia_settings!","text":"validate_sequoia_settings!(settings::SEQUOIA_Settings)\n\nValidates the fields of a SEQUOIA_Settings instance, applying default values where needed and issuing warnings.\n\nArguments:\n\nsettings: The SEQUOIA_Settings instance to validate.\n\nModifies:\n\nMutates settings by applying default values if required.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.validate_sequoia_solution!-Tuple{SEQUOIA_Solution_step}","page":"API Reference","title":"Sequoia.validate_sequoia_solution!","text":"validate_sequoia_solution!(solution::SEQUOIA_Solution_step)\n\nValidates the fields of a SEQUOIA_Solution_step instance. This function ensures the correctness and consistency  of the solution vector, gradients and metadata.\n\nArguments\n\nsolution: An instance of SEQUOIA_Solution_step to validate.\n\nThrows\n\nArgumentError if any of the validation checks fail.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.validate_solver_status-Tuple{Symbol}","page":"API Reference","title":"Sequoia.validate_solver_status","text":"validate_solver_status(status::Symbol)\n\nChecks if the solver status is valid by ensuring it is one of the allowed symbols in SolverStatus. Throws an ArgumentError if the status is not valid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sequoia.validate_x0-Tuple{Vector{Float64}, Int64}","page":"API Reference","title":"Sequoia.validate_x0","text":"validate_x0(x0::Vector{Float64}, nvar::Int)\n\nValidates that the length of the initial guess vector x0 matches the number of variables nvar.\n\nArguments\n\nx0: The initial guess vector.\nnvar: The expected number of variables.\n\nThrows\n\nArgumentError if the length of x0 does not match nvar.\n\n\n\n\n\n","category":"method"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To install SEQUOIA.jl, use Julia's package manager:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"Sequoia\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Basic Usage To configure an optimization problem, create a SEQUOIA_Settings object:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Sequoia\n\nsettings = SEQUOIA_Settings(\n    :SEQUOIA, :LBFGS, false, 1e-8, 1000, 3600.0, 1e-5,\n    conv_crit = :GradientNorm,\n    max_iter_inner = 500\n)","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This page contains practical examples to demonstrate how to use the SEQUOIA_Settings struct in different scenarios. These examples showcase both minimal and advanced configurations for optimization problems.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/#Example-1:-Using-the-Full-Constructor","page":"Examples","title":"Example 1: Using the Full Constructor","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The full constructor allows you to specify all fields, including optional parameters like cost_tolerance and solver_params.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Sequoia\n\nsettings_full = SEQUOIA_Settings(\n    :SEQUOIA,          # Outer method\n    :LBFGS,            # Inner solver\n    false,             # Feasibility: solving an optimization problem\n    1e-8,              # Residual tolerance for constraints\n    1000,              # Max iterations for outer solver\n    3600.0,            # Max time for outer solver in seconds\n    1e-5,              # Gradient norm tolerance\n    conv_crit = :GradientNorm, # Convergence criterion\n    max_iter_inner = 500,      # Max inner iterations\n    max_time_inner = 300.0,    # Max time for inner solver\n    store_trace = true,        # Enable tracing\n    cost_tolerance = 1e-4,     # Desired optimality gap\n    cost_min = -1e6,           # Minimum cost\n    step_min = 1e-8,           # Minimum step size\n    solver_params = [1.0, 0.5] # Solver-specific parameters\n)\n\nprintln(settings_full)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"#= Output: SEQUOIASettings(:SEQUOIA, :LBFGS, false, 1.0e-8, 1000, 3600.0, :GradientNorm, 500, 300.0, true, 0.0001, -1.0e6, 1.0e-8, [1.0, 0.5]) Example 2: Using the Minimal Constructor The minimal constructor lets you define only the required fields. Default values are applied to optional parameters such as convergencecriteria, costtolerance, and solverparams.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia Copy code using Sequoia","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"settingsmin = SEQUOIASettings(     :QPM,              # Outer method     :Newton,           # Inner solver     true,              # Feasibility: solving a feasibility problem     1e-6,              # Residual tolerance for constraints     500,               # Max iterations for outer solver     1800.0,            # Max time for outer solver in seconds     1e-6               # Gradient norm tolerance for the inner solver )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"println(settings_min) Output:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"vbnet Copy code SEQUOIASettings(:QPM, :Newton, true, 1.0e-6, 500, 1800.0, :GradientNorm, nothing, nothing, false, nothing, nothing, nothing, nothing) Example 3: Error Handling with Invalid Inputs When invalid inputs are provided, SEQUOIASettings raises descriptive errors to guide the user.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Invalid Outer Method julia Copy code using Sequoia","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"try     settingsinvalid = SEQUOIASettings(         :InvalidMethod,     # Invalid outer method         :LBFGS,             # Inner solver         false,              # Feasibility         1e-8,               # Residual tolerance         1000,               # Max iterations         3600.0              # Max time     ) catch e     println(e)  # Prints: \"Invalid outer method: :InvalidMethod. Valid methods are: QPM, AugLag, IntPt, SEQUOIA.\" end Example 4: Custom Solver Parameters Custom solver parameters can be passed to fine-tune optimization behavior. For example, you might want to specify step sizes or penalty parameters.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia Copy code using Sequoia","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"settingswithparams = SEQUOIASettings(     :AugLag,            # Outer method     :GradientDescent,   # Inner solver     false,              # Feasibility     1e-6,               # Residual tolerance     800,                # Max iterations     3000.0,             # Max time     1e-5,               # Gradient norm tolerance     convcrit = :MaxIterations, # Convergence criterion     maxiterinner = 100,       # Max inner iterations     stepmin = 1e-6,            # Minimum step size     solverparams = [0.01, 10.0] # Custom solver parameters )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"println(settingswithparams) Output:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ruby Copy code SEQUOIASettings(:AugLag, :GradientDescent, false, 1.0e-6, 800, 3000.0, :MaxIterations, 100, nothing, false, nothing, nothing, 1.0e-6, [0.01, 10.0]) Example 5: Debugging an Optimization Problem Enable storetrace to record intermediate states of the optimization process for debugging:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia Copy code using Sequoia","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"settingsdebug = SEQUOIASettings(     :SEQUOIA,          # Outer method     :LBFGS,            # Inner solver     false,             # Feasibility     1e-6,              # Residual tolerance     500,               # Max iterations     3600.0,            # Max time     1e-5,              # Gradient norm tolerance     store_trace = true # Enable debugging trace )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"println(settings_debug) Output:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"vbnet Copy code SEQUOIA_Settings(:SEQUOIA, :LBFGS, false, 1.0e-6, 500, 3600.0, :GradientNorm, nothing, nothing, true, nothing, nothing, nothing, nothing) =#","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<img class=\"display-light-only\" src=\"assets/sequoia_logo.svg\" alt=\"Sequoia logo\"/>","category":"page"},{"location":"#SEQUOIA.jl","page":"Introduction","title":"SEQUOIA.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the documentation for the SEQUOIA.jl package!","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SEQUOIA.jl is a Julia package designed for flexible and customizable optimization. It provides:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Support for various optimization methods like QPM, AugLag, IntPt, and SEQUOIA.\nConfigurable solvers for inner and outer optimization loops.\nExtensive validation and error handling.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Start by reading the Getting Started guide!","category":"page"}]
}
